import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import ta
import yfinance as yf

# This part of the code is responsible for acquiring market data

def get_marktet_data(symbol, start_date, end_date):
    data = yf.download(symbol, start=start_date, end=end_date)
    if isinstance(data.columns, pd.MultiIndex):
        data.columns = data.columns.get_level_values(0)
    return data



# This part of the code is responsible for building a backtesting engine
class BacktestingEngine:
    def __init__(self, data, cash):
        self.data = data
        self.portfolio = {'cash': cash, 'positions': {}}
        self.trades = []

    
    # This function exectues trades based on the signals generated by the strategy
    def execute_trade(self, symbol, quantity, price):
        self.portfolio['cash'] -= quantity * price

        if symbol in self.portfolio['positions']:
            self.portfolio['positions'][symbol] += quantity
        else:
            self.portfolio['positions'][symbol] = quantity
        
        self.trades.append({
            'symbol': symbol,
            'quantity': quantity,
            'price': price
        })

    # This function runs the backtest by iterating through the data and executing trades based on the signals
    def run_backtest(self, risk):

        for index, row in self.data.iterrows():
            close_price = row['Close']
            signal = row['signal']

            # Check if the signal is a buy signal
            if signal == 1:
                available_cash = self.portfolio['cash']
                position_size = available_cash * risk / close_price
                self.execute_trade(symbol=self.data.name, quantity=position_size, price = close_price)
            # Check if the signal is a sell signal
            elif signal == 0:
                position_size = self.portfolio['positions'].get(self.data.name, 0)
                if position_size > 0:
                    self.execute_trade(symbol=self.data.name, quantity=-position_size, price=close_price)

    # This function calculates the performance of the backtest based on the executed trades
    def calculate_performance(self):
        trade_prices = np.array([trade['price'] for trade in self.trades])
        trade_quantities = np.array([trade['quantity'] for trade in self.trades])

        trade_returns = np.diff(trade_prices) / trade_prices[:-1]
        trade_pnl = trade_returns * trade_quantities[:-1]

        total_pnl = np.sum(trade_pnl)
        average_trade_return = np.mean(trade_returns)
        win_ratio = np.sum(trade_pnl > 0) / len(trade_pnl)

        return total_pnl, average_trade_return, win_ratio

    # This function calculates the current value of the portfolio based on the current price 
    def get_portfolio_value(self, price):
        positions_value = sum(self.portfolio['positions'].get(symbol, 0) * price for symbol in self.portfolio['positions'])
        return self.portfolio['cash'] + positions_value
    
    # This function calculates the daily returns of the portfolio
    def get_portfolio_returns(self):
        portfolio_value = [self.get_portfolio_value(row['Close']) for _, row in self.data.iterrows()]
        returns = np.diff(portfolio_value) / portfolio_value[:-1]
        return returns
    
    # This function plots the portfolio value over time
    def plot_portfolio_value(self):
        portfolio_value = [self.get_portfolio_value(row['Close']) for _, row in self.data.iterrows()]
        dates = self.data.index
        signals = self.data['signal']

        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plot portfolio value
        ax1.plot(dates, portfolio_value, label='Portfolio Value')
        ax1.set_xlabel('Date')
        ax1.set_ylabel('Portfolio Value')
        ax1.set_title('Portfolio Value Over Time')

        # Plot buy/sell signals
        ax2 = ax1.twinx()
        ax2.plot(dates, signals, 'r-', label='Buy/Sell Signal')
        ax2.set_ylabel('Signal')
        ax2.grid(None)

        fig.tight_layout()
        plt.show()


def main():
    print("Enter the stock symbol you want to backtest:")
    symbol = input().strip()
    print("Enter the start date (YYYY-MM-DD):")
    start_date = input().strip()
    print("Enter the end date (YYYY-MM-DD):")
    end_date = input().strip()

    data = get_marktet_data(symbol, start_date, end_date)

    print("Enter the initial cash amount:")
    initial_cash = float(input().strip())
    print("Enter the risk percentage (0-1):")
    risk = float(input().strip())

    # Define Any trading strategy here
    sma_short = ta.trend.sma_indicator(close=data['Close'], window=20)
    sma_long = ta.trend.sma_indicator(close=data['Close'], window=50)
    data['signal'] = np.where(sma_short > sma_long, 1, 0)  # Buy signal when short SMA is above long SMA
    data.name = symbol
    
    engine = BacktestingEngine(data, initial_cash)
    initial_portfolio_value = engine.get_portfolio_value(data.iloc[0]['Close'])

    engine.run_backtest(risk)

    # Evaluate Performance
    final_portfolio_value = engine.get_portfolio_value(data.iloc[-1]['Close'])
    returns = engine.get_portfolio_returns()
    total_returns = (final_portfolio_value - initial_portfolio_value) / initial_portfolio_value
    annualized_returns = (1 + total_returns) ** (365 / len(data)) - 1
    volatility = np.std(returns) * np.sqrt(365)
    sharpe_ratio = (annualized_returns - 0.0276) / volatility if volatility != 0 else 0
    
    engine.plot_portfolio_value()

    total_pnl, average_trade_return, win_ratio = engine.calculate_performance()
    print('Here are the performance metrics:')
    print(f'Total Returns: {total_returns:.2%}')
    print(f'Annualized Returns: {annualized_returns:.2%}')
    print(f'Volatility: {volatility:.2%}')
    print(f'Sharpe Ratio: {sharpe_ratio:.2f}')
    print(f'Total P&L: {total_pnl:.2f}')
    print(f'Average Trade Return: {average_trade_return:.2%}')
    print(f'Win Ratio: {win_ratio:.2%}')

if __name__ == '__main__':
    main()